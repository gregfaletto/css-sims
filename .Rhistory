2*sqrt(2*9.8*5)
.4*60*9.8
60*(4/3-4)
120*4/3
v1i <- c(2, -3, 1)
v2i <- c(-1, 2, -3)
v1f <- c(-1, 3, 8)
(.5*v1i  + 1.5*v2i - .5*v1f)/1.5
library(MASS)
fractions((.5*v1i  + 1.5*v2i - .5*v1f)/1.5)
v1i <- c(2, -3, 1)
v2i <- c(-1, 2, -3)
v1f <- c(-1, 3, 8)
# final velocity
v2f <- (.5*v1i  + 1.5*v2i - .5*v1f)/1.5
print("final velocity:")
print(v2f)
# initial KE
kei <- .5*sum(v1i^2) + .5*sum(v2i^2)
kef <- .5*sum(v1f^2) + .5*sum(v2f^2)
print("initial ke:")
print(kei)
print("final ke:")
print(kef)
problem <- function(v1f){
stopifnot(length(v1f) == 3)
v1i <- c(2, -3, 1)
v2i <- c(-1, 2, -3)
# final velocity
v2f <- (.5*v1i  + 1.5*v2i - .5*v1f)/1.5
print("final velocity:")
print(v2f)
# initial KE
kei <- .5*sum(v1i^2) + .5*sum(v2i^2)
kef <- .5*sum(v1f^2) + .5*sum(v2f^2)
print("initial ke:")
print(kei)
print("final ke:")
print(kef)
}
problem(c(-1, 3, 8))
problem(c(-1, 3, 8))
problem(c(-.25, .75, -2))
(.5 + 1.5*(-3) - 0.5*(-8))/1.5
problem(c(-1, 3, -8))
problem(c(-.25, .75, -2))
.5 = 4.5
(.5 - 4.5)/1.5
fractions((.5 - 4.5)/1.5)
1.5*(c(-.25, .75, -2))
fractions(1.5*(c(-.25, .75, -2)))
.5*.5*(2^2 + 3^2 + 1) + .5*1.5*(1 + 2^2 + 3 ^3)
.5*.5*(2^2 + 3^2 + 1) + .5*1.5*(1 + 2^2 + 3 ^2)
problem(c(-1, 3, 2.743))
(.5 - 4.5)/1.5
fractions((.5 - 4.5)/1.5)
.5*.5*(2^2 + 3^2 + 1)
.5*1.5*(2^2 + 3^2 + 1)
problem(c(-1, 3, 2.743))
problem(c(-1, 3, -8))
problem <- function(v1f){
stopifnot(length(v1f) == 3)
v1i <- c(2, -3, 1)
v2i <- c(-1, 2, -3)
# final velocity
v2f <- (.5*v1i  + 1.5*v2i - .5*v1f)/1.5
print("final velocity:")
print(v2f)
# initial KE
kei <- .5*.5*sum(v1i^2) + .5*1.5*sum(v2i^2)
kef <- .5*.5*sum(v1f^2) + .5*1.5*sum(v2f^2)
print("initial ke:")
print(kei)
print("final ke:")
print(kef)
}
problem(c(-1, 3, -8))
problem(c(-.25, .75, -2))
problem(c(-1, 3, 2.743))
.5*1.5*(1^2 + 2^2 + 3^2)
problem(c(-1, 3, -8))
problem(c(-.25, .75, -2))
r <- 2
250*10/(250+25*r^2)
(.1*5)/(.1*.2 + .5*1*.2)
10/sqrt(100*log(100))
99^2
19*log(100)^(3/4)/100
sqrt(3.61)
45/4
2*10^(-6)/(1.609*10^(-19))
.04*9.81
k <- 9*10^9
q <- 2*10^(-6)
r <- .15
m <- .04
k*q^2/r^2 - .4*9.81
k*q^2/r^2
k <- 8.99*10^9
k*q^2/r^2 - .4*9.81
k*q^2/r^2 - m*9.81
q <- (-24*10^(-6))/2
k*q^2/.6^2
1/2*3/4
q1 <- 40*10^(-6)
q_A <- 40*10^(-6)
q_B <- 50*10^(-6)
q_C <- 4*10^(-6)
k*q_A*q_C/.2^2 + k*q_B*q_C/.3^2
k*20*10^(-6)/.1^2 + k*8*10^(-6)/.1^2
1.1^2*500*10^(-9)/2^2*sqrt(3)/2
k*2*10^(-9)/.1^2
2*cos(36.9*pi/180)
cos(36.9*pi/180)
sqrt(0.8*10*1.6/sin(36.9*pi/180))
factorial(9)/(factorial(3)*factorial(6))
factorial(9)
6/9*5/8*4/7
MASS::fractions(6/9*5/8*4/7)
MASS::fractions(3/9*2/8*1/7)
1/84
?dnorm
pnorm(140, mean=120, sd=10.5)
1-pnorm(140, mean=120, sd=10.5)
.4^3
MASS::fractions(.4^3)
(5*10^6 - 1)/(10^7-1)
4*3400
4*3400*12
.9^2*.1
?pgeom
pgeom(q=3, prob=0.1)
dgeom(3, 0.1)
.1 + .9*.1 +.9^2*.1
1 - .1 - .9*.1
1/.7
1/.3
sqrt(1 - .3)/.3
1/.7 + 1/.7
.25^3
1/.75
32*.25^3
1/.88
1/.88*3
sqrt(1 - .88)/.88
100*1.136364
0.3936479*100
x <- -3:3
p <- c(1/16, 2/16, 3/16, 4/16, 3/16, 2/16, 1/16)
sum(p)
(x^2)%*%p
sqrt(2.5)
x <- c(500, 100, 10, 0)
p <- c(1, 4, 10, 2345)/2400
sum(p)
p <- c(1, 4, 10, 2385)/2400
sum(p)
m <- x %*%p
m
(x - m)^2 %*%p
p
x
m
m <- as.numeric(m)
(x - m)^2 %*% p
sqrt((x - m)^2 %*% p)
5*m
x <- c(-1000, 0, 1000, 2000, 3000)
p <- c(0.13, 0.15, 0.24, 0.35, 0.13)
sum(p)
x %*% p
.55^10
1 - .55^10 - 10*.45*.55^9
?rbinom
pbinom(q=5,size=10,prob=0.45)
dbinom(x=3,size=5,prob=1/4)
?rnorm
qnorm(p=.7,mean=125,sd=6.5)
1 - dbinom(x=1, size=5, prob=0.3)
1 - .7^5 - 5*.3*.7^4
(1 - .19)^4*.19
1/.81
?rgeom
1 - pgeom(q=10, prob=0.19)
pgeom(q=10, prob=.19)
pgeom(q=1, p=.19)
pgeom(q=1, prob=.19)
pgeom(q=0, prob=.19)
1 - pgeom(q=9, prob=0.19)
.6^4 + .3*.6^3*4
1-0.5248
pbinom(q=2, size=4, prob=0.6)
.4^4 + 4*.4^3*.6+6*.4^2+.6^2
.4^4 + 4*.4^3*.6+6*.4^2*.6^2
.6^4 + .4*.6^3*4
15*.6
sqrt(15*.6*.4)
15*.6*.4
sqrt(15*.6*.4)
2*sin(pi/6)
m <- 2
g <- 9.8
m*g
.5*m*7^2-m*g*1
sqrt(2/m*(.5*m*7^2-m*g*1))
-m*g*sin(pi/6)*2
m*g
m*g*2*cos(2*pi/3)
-2^3-4*2
sqrt(2/4*(50 - 18))
sqrt(2/4*(50 - 12))
k <- 25
g <- 9.8
m <- .2
g <- 10
(m*g + sqrt(m^2*g^2 - 4*.5*k*.3*m*g))/(2*.5*k)
(m*g + sqrt(m^2*g^2 + 4*.5*k*.3*m*g))/(2*.5*k)
(m*g - sqrt(m^2*g^2 + 4*.5*k*.3*m*g))/(2*.5*k)
5*3 + 5*9.81
5*3 + 5*10
0.05*645/64.5
0.05*645
49/(2*.5)
425*cos(35.2*pi/180)
425*sin(35.2*pi/180)
325+245
347.3/570
string <- "apple"
string[1]
split(string)
strsplit(string)
strsplit(string, "")
?strsplit
strsplit(string, "")[[1]]
?paste
chars <-strsplit(string, "")[[1]]
cars
chars
?identical
?paste
8*.15
.56-3
4-1.2
725*1.5/625
.5*(625/9.8)*1.74^2 + .5*(725/9.8)*1.5^2
.5*(625/10)*1.74^2 + .5*(725/10)*1.5^2
.5*(625/10)*1.74^2
.5*(725/10)*1.5^2
(.25*-.12+.35*.65)/.25
(.25*-.12+.35*.65)
25*-.1
25*-.12
.25*-.12
.35*.65
(.25*-.12+.35*.65)/.25
.25*-.12+.35*.65
.5*.25*.79^2
.5*.25*.012^2 + .5*.35*.65^2
0.0739555-0.0780125
?glmnet
library(glmnet)
?glmnet
# Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
fit = glmnet(x, y, family="gaussian")
lasso_sets <- unique(predict(fit, type="nonzero"))
lasso_sets
str(lasso_sets)
?css
library(cssr)
?css
5 %in% integer()
5 %in% 1:4
5 %in% 1:5
5L %in% 1:5
5 %in% 1L:5L
fit
glmnet::predict.glmnet(fit)
glmnet::predict.glmnet(fit, type="nonzero")
citation(glmnet)
citation("glmnet")
?order
K <- 10
p <- 20
# Generate 2K random matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_list[[i]] <- matrix(rnorm(p^2), p, p)
min_eigens[i] <- min(eigen(mat_list[[i]])$values)
}
matrix(rnorm(p^2), p, p)
min(eigen(matrix(rnorm(p^2), p, p))$values)
eigen(matrix(rnorm(p^2), p, p)
)
mat_i <- matrix(rnorm(p^2), p, p)
eigen(mat_i)
eigen(mat_i)$values
rm(list=ls())
K <- 10
p <- 20
# Generate 2K random matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_i <- matrix(rnorm(p^2), p, p)
mat_list[[i]] <- mat_i
min_eigens[i] <- min(eigen(mat_i)$values)
}
eigen(mat_i)$values
min(eigen(mat_i)$values)
rm(list=ls())
K <- 10
p <- 20
n <- 30
# Generate 2K random PSD matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_i <- matrix(rnorm(n*p), n, p)
stopifnot(nrow(t(mat_i) %*% mat_i) == p)
mat_list[[i]] <- t(mat_i) %*% mat_i
min_eigens[i] <- min(eigen(t(mat_i) %*% mat_i)$values)
}
# Label them as X and Y adversarially (min eigenvalues of X are just larger than
# min eigenvalues of Y)
inds <- order(min_eigens, decreasing=TRUE)
# The ones in inds 1, 3,... will be X and inds 2, 4... will be Y
X <- matrix(0, p, p)
Y <- matrix(0, p, p)
for(k in 1:K){
X <- X + mat_list[[2*k - 1]]
Y <- Y + mat_list[[2*k]]
}
# Test
min_eigen_diff <- min(eigen(X - Y)$values)
inds
min_eigens[inds]
# Label them as X and Y adversarially (min eigenvalues of X are just larger than
# min eigenvalues of Y)
inds <- order(min_eigens, decreasing=TRUE)
# The ones in inds 1, 3,... will be X and inds 2, 4... will be Y
X <- matrix(0, p, p)
Y <- matrix(0, p, p)
for(k in 1:K){
X <- X + mat_list[[inds[2*k - 1]]]
Y <- Y + mat_list[[inds2*k]]]
for(k in 1:K){
X <- X + mat_list[[inds[2*k - 1]]]
Y <- Y + mat_list[[inds[2*k]]]
}
# Test
min_eigen_diff <- min(eigen(X - Y)$values)
print("minimum eigenvalue of difference:")
print(min_eigen_diff)
K <- 10
p <- 20
n <- 30
# Generate 2K random PSD matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_i <- matrix(rnorm(n*p), n, p)
stopifnot(nrow(t(mat_i) %*% mat_i) == p)
mat_list[[i]] <- t(mat_i) %*% mat_i
min_eigens[i] <- min(eigen(t(mat_i) %*% mat_i)$values)
}
# Label them as X and Y adversarially (min eigenvalues of X are just larger than
# min eigenvalues of Y)
inds <- order(min_eigens, decreasing=TRUE)
# The ones in inds 1, 3,... will be X and inds 2, 4... will be Y
X <- matrix(0, p, p)
Y <- matrix(0, p, p)
for(k in 1:K){
X_k <- mat_list[[inds[2*k - 1]]]
Y_k <- mat_list[[inds[2*k]]]
# double check
stopifnot(min(eigen(X_k)$value) >= min(eigen(Y_k)$value))
X <- X + X_k
Y <- Y + Y_k
}
# Test
min_eigen_diff <- min(eigen(X - Y)$values)
print("minimum eigenvalue of difference:")
print(min_eigen_diff)
K <- 10
p <- 20
n <- 30
# Generate 2K random PSD matrices
mat_list <- list()
rm(list=ls())
K <- 10
p <- 20
n <- 30
# Generate 2K random PSD matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_i <- matrix(rnorm(n*p), n, p)
stopifnot(nrow(t(mat_i) %*% mat_i) == p)
mat_list[[i]] <- t(mat_i) %*% mat_i
min_eigens[i] <- min(eigen(t(mat_i) %*% mat_i)$values)
}
X <- matrix(0, p, p)
Y <- matrix(0, p, p)
for(k in 1:K){
X_k <- mat_list[[i]]
# Construct Y_k that is a little bit smaller
Y_k <- X_k - diag(p)*min_eigens[i]/2
# double check
stopifnot(min(eigen(X_k - Y_k)$value) >= 0)
X <- X + X_k
Y <- Y + Y_k
}
# Test
min_eigen_diff <- min(eigen(X - Y)$values)
print("minimum eigenvalue of difference:")
print(min_eigen_diff)
for(j in 1:20){
K <- 10
p <- 20
n <- 30
# Generate 2K random PSD matrices
mat_list <- list()
# Keep track of minimum eigenvalues
min_eigens <- numeric(2*K)
for(i in 1:(2*K)){
mat_i <- matrix(rnorm(n*p), n, p)
stopifnot(nrow(t(mat_i) %*% mat_i) == p)
mat_list[[i]] <- t(mat_i) %*% mat_i
min_eigens[i] <- min(eigen(t(mat_i) %*% mat_i)$values)
}
X <- matrix(0, p, p)
Y <- matrix(0, p, p)
for(k in 1:K){
X_k <- mat_list[[i]]
# Construct Y_k that is a little bit smaller
Y_k <- X_k - diag(p)*min_eigens[i]/2
# double check
stopifnot(min(eigen(X_k - Y_k)$value) >= 0)
X <- X + X_k
Y <- Y + Y_k
}
# Test
min_eigen_diff <- min(eigen(X - Y)$values)
print("minimum eigenvalue of difference:")
print(min_eigen_diff)
}
remotes::install_github("jacobbien/litr-project", subdir = "litr",force=TRUE)
remotes::install_github("gregfaletto/cssr-project", subdir = "cssr")
library(cssr)
?genClusteredData
makeCovarianceMatrixWeighted <- function(p, nblocks, block_size,
n_strong_block_vars, rho_high, rho_low, var) {
# Check inputs
stopifnot(nblocks >= 1)
stopifnot(rho_high != 0)
stopifnot(rho_low != 0)
stopifnot(abs(rho_high) >= abs(rho_low))
stopifnot(var != 0)
stopifnot(abs(rho_high) <= abs(var))
stopifnot(block_size >= 2)
stopifnot(p >= nblocks*block_size)
stopifnot(n_strong_block_vars <= block_size)
# start with p x p identity matrix
Sigma <- var*diag(p)
# create matrix with nblocks rows, each containing a vector of
# indices of highly correlated features
block_feats <- matrix(seq(nblocks*block_size), nrow=nblocks, byrow=TRUE)
stopifnot(length(unique(block_feats)) == length(block_feats))
# add covariances of highly correlated features to sigma
for(i in 1:nblocks){
for(j in 1:(block_size - 1)){
for(k in (j+1):block_size){
feat_1 <- block_feats[i, j]
feat_2 <- block_feats[i, k]
Sigma[feat_1, feat_2] <- rho_low
Sigma[feat_2, feat_1] <- rho_low
}
}
for(j in 1:(n_strong_block_vars - 1)){
for(k in (j+1):n_strong_block_vars){
feat_1 <- block_feats[i, j]
feat_2 <- block_feats[i, k]
Sigma[feat_1, feat_2] <- rho_high
Sigma[feat_2, feat_1] <- rho_high
}
}
}
stopifnot(is.numeric(Sigma))
stopifnot(is.matrix(Sigma))
stopifnot(nrow(Sigma) == p & ncol(Sigma) == p)
stopifnot(all(Sigma == t(Sigma)))
return(Sigma)
}
makeCovarianceMatrixWeighted(p=8, nblocks=1, block_size=5, n_strong_block_vars=2, rho_high=0.9, rho_low=0.5, var=1)
eigen(makeCovarianceMatrixWeighted(p=8, nblocks=1, block_size=5, n_strong_block_vars=2, rho_high=0.9, rho_low=0.5, var=1))$values
2*3^4
library(MASS)
.5*1/6*(1/4)^2
fractions(.5*1/6*(1/4)^2)
library(cssr)
citation("cssr")
setwd("/Users/gregfaletto/Documents/GitHub/css-sims")
source("sim_5_1.R")
source("sim_5_1.R")
